////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#include "system_utils.h"

#include <stdio.h>
#include <stdlib.h>
#include <stddef.h>
#include <string.h>


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

Result ok(void *value, const char *msg) {
    Result res;
    res.error_code = OK;
    res.value = value;
    snprintf(res.message, MAX_MSG_LENGTH, "%s", msg);
    return res;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

Result err(const char *msg) {
    Result res;
    res.error_code = ERR;
    res.value = NULL;
    snprintf(res.message, MAX_MSG_LENGTH, "%s", msg);
    return res;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


void *unwrap(Result res) {
    if (res.error_code == ERR) {
        fprintf(stderr, "Unwrap error: %s\n", res.message);
        exit(EXIT_FAILURE);
    }
    return res.value;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void *unwrap_or(Result res, void *default_value) {
    if (res.error_code == ERR) {
        return default_value;
    }
    return res.value;
}




////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

Result list_init() {
    List *list = malloc(sizeof(List));
    if (!list) return err("Allocation failed for List struct");

    list->items = malloc(INITIAL_CAPACITY * sizeof(void *));
    if (!list->items) {
        free(list);
        return err("Allocation failed for list items");
    }

    list->size = 0;
    list->capacity = INITIAL_CAPACITY;
    return ok(list, "List initialized successfully");
}


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

Result list_deinit(List *list, void (*free_func)(void *)) {
    if (!list) return err("List pointer is NULL");

    if (free_func) {
        for (size_t i = 0; i < list->size; i++) {
            free_func(list->items[i]);
        }
    }

    free(list->items);
    free(list);
    return ok(NULL, "List deinitialized successfully");
}



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

Result list_add(List *list, void *item) {
    if (!list) return err("List is NULL");

    if (list->size >= list->capacity) {
        size_t new_capacity = list->capacity * 2;
        void **new_items = realloc(list->items, new_capacity * sizeof(void *));
        if (!new_items) return err("Memory reallocation failed");

        list->items = new_items;
        list->capacity = new_capacity;
    }

    list->items[list->size++] = item;
    return ok(NULL, "Item added");
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

Result list_get(List *list, size_t index) {
    if (!list) return err("List is NULL");
    if (index >= list->size) return err("Index out of bounds");

    return ok(list->items[index], "Item retrieved");
}


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

Result list_set(List *list, size_t index, void *item) {
    if (!list) return err("List is NULL");
    if (index >= list->size) return err("Index out of bounds");

    list->items[index] = item;
    return ok(NULL, "Item set");
}


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

Result list_remove(List *list, size_t index, void (*free_func)(void *)) {
    if (!list) return err("List is NULL");
    if (index >= list->size) return err("Index out of bounds");

    if (free_func) {
        free_func(list->items[index]);
    }

    for (size_t i = index; i < list->size - 1; i++) {
        list->items[i] = list->items[i + 1];
    }

    list->size--;
    return ok(NULL, "Item removed");
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

